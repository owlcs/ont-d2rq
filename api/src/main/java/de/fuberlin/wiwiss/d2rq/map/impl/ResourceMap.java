package de.fuberlin.wiwiss.d2rq.map.impl;

import de.fuberlin.wiwiss.d2rq.D2RQException;
import de.fuberlin.wiwiss.d2rq.algebra.*;
import de.fuberlin.wiwiss.d2rq.algebra.AliasMap.Alias;
import de.fuberlin.wiwiss.d2rq.expr.SQLExpression;
import de.fuberlin.wiwiss.d2rq.map.AdditionalProperty;
import de.fuberlin.wiwiss.d2rq.map.ClassMap;
import de.fuberlin.wiwiss.d2rq.map.Database;
import de.fuberlin.wiwiss.d2rq.map.TranslationTable;
import de.fuberlin.wiwiss.d2rq.nodes.FixedNodeMaker;
import de.fuberlin.wiwiss.d2rq.nodes.NodeMaker;
import de.fuberlin.wiwiss.d2rq.nodes.TypedNodeMaker;
import de.fuberlin.wiwiss.d2rq.nodes.TypedNodeMaker.NodeType;
import de.fuberlin.wiwiss.d2rq.pp.PrettyPrinter;
import de.fuberlin.wiwiss.d2rq.sql.ConnectedDB;
import de.fuberlin.wiwiss.d2rq.sql.SQL;
import de.fuberlin.wiwiss.d2rq.values.*;
import de.fuberlin.wiwiss.d2rq.values.ValueDecorator.ValueConstraint;
import de.fuberlin.wiwiss.d2rq.vocab.AVC;
import de.fuberlin.wiwiss.d2rq.vocab.D2RQ;
import org.apache.jena.datatypes.RDFDatatype;
import org.apache.jena.datatypes.TypeMapper;
import org.apache.jena.rdf.model.*;
import org.apache.jena.util.iterator.ExtendedIterator;
import ru.avicomp.ontapi.jena.utils.Iter;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;

/**
 * @author Richard Cyganiak (richard@cyganiak.de)
 */
@SuppressWarnings("WeakerAccess")
abstract class ResourceMap extends MapObjectImpl {

    public ResourceMap(Resource resource, MappingImpl mapping) {
        super(resource, mapping);
    }

    public ResourceMap setDatabase(Database database) {
        DatabaseImpl res = mapping.asDatabase(database.asResource()).copy(database);
        return setRDFNode(D2RQ.dataStorage, res.asResource());
    }

    public boolean isAutoGenerated() {
        return getBoolean(AVC.autoGenerated, false);
    }

    public ResourceMap setAutoGenerated() {
        return setBoolean(AVC.autoGenerated, true);
    }

    public DatabaseImpl getDatabase() {
        return findFirst(D2RQ.dataStorage, Statement::getResource).map(mapping::asDatabase).orElse(null);
    }

    public ResourceMap addAdditionalProperty(AdditionalProperty property) {
        AdditionalPropertyImpl res = mapping.asAdditionalProperty(property.asResource()).copy(property);
        return addRDFNode(additionalPropertyPredicate(), res.asResource());
    }

    public Stream<AdditionalProperty> additionalProperties() {
        return Iter.asStream(listAdditionalProperties());
    }

    public ExtendedIterator<AdditionalPropertyImpl> listAdditionalProperties() {
        return resource.listProperties(additionalPropertyPredicate())
                .mapWith(s -> mapping.asAdditionalProperty(s.getResource()));
    }

    public ResourceMap addComment(Literal value) {
        return addRDFNode(definitionCommentPredicate(), value);
    }

    public Stream<Literal> comments() {
        return Iter.asStream(listComments());
    }

    public ExtendedIterator<Literal> listComments() {
        return listLiterals(definitionCommentPredicate());
    }

    public ResourceMap addLabel(Literal value) {
        return addRDFNode(definitionLabelPredicate(), value);
    }

    public Stream<Literal> labels() {
        return Iter.asStream(listLabels());
    }

    public ExtendedIterator<Literal> listLabels() {
        return listLiterals(definitionLabelPredicate());
    }

    Property definitionLabelPredicate() {
        throw new IllegalStateException();
    }

    Property definitionCommentPredicate() {
        throw new IllegalStateException();
    }

    Property additionalPropertyPredicate() {
        throw new IllegalStateException();
    }

    public ResourceMap setBNodeIdColumns(String columns) {
        return setLiteral(D2RQ.bNodeIdColumns, columns);
    }

    public String getBNodeIdColumns() {
        return getString(D2RQ.bNodeIdColumns);
    }

    public ResourceMap setURIColumn(String column) {
        return setLiteral(D2RQ.uriColumn, column);
    }

    public String getURIColumn() {
        return getString(D2RQ.uriColumn);
    }

    public ResourceMap setURIPattern(String pattern) {
        return setLiteral(D2RQ.uriPattern, pattern);
    }

    public String getURIPattern() {
        return getString(D2RQ.uriPattern);
    }

    public ResourceMap setUriSQLExpression(String uriSqlExpression) {
        return setLiteral(D2RQ.uriSqlExpression, uriSqlExpression);
    }

    public String getUriSQLExpression() {
        return getString(D2RQ.uriSqlExpression);
    }

    public ResourceMap setConstantValue(RDFNode value) {
        return setRDFNode(D2RQ.constantValue, value);
    }

    public RDFNode getConstantValue() {
        return constantValue().orElse(null);
    }

    public Optional<RDFNode> constantValue() {
        return findFirst(D2RQ.constantValue, Statement::getObject);
    }

    public ResourceMap setConstantValue(String uri) {
        return setURI(D2RQ.constantValue, uri);
    }

    public ResourceMap addValueRegex(String regex) {
        return addLiteral(D2RQ.valueRegex, regex);
    }

    public ExtendedIterator<String> listValueRegexes() {
        return listStrings(D2RQ.valueRegex);
    }

    public Stream<String> valueRegexes() {
        return Iter.asStream(listValueRegexes());
    }

    public ResourceMap addValueContains(String contains) {
        return addLiteral(D2RQ.valueContains, contains);
    }

    public ExtendedIterator<String> listValueContains() {
        return listStrings(D2RQ.valueContains);
    }

    public Stream<String> valueContains() {
        return Iter.asStream(listValueContains());
    }

    public ResourceMap setValueMaxLength(int maxLength) {
        return setInteger(D2RQ.valueMaxLength, maxLength);
    }

    public Integer getValueMaxLength() {
        return findFirst(D2RQ.valueMaxLength, s -> s.getLiteral().getInt()).orElse(null);
    }

    public ResourceMap setTranslateWith(TranslationTable table) {
        TranslationTableImpl res = mapping.asTranslationTable(table.asResource()).copy(table);
        return setRDFNode(D2RQ.translateWith, res.asResource());
    }

    public TranslationTableImpl getTranslateWith() {
        return findFirst(D2RQ.translateWith, Statement::getResource).map(mapping::asTranslationTable).orElse(null);
    }

    public ResourceMap addJoin(String join) {
        return addLiteral(D2RQ.join, join);
    }

    public Stream<String> joins() {
        return Iter.asStream(listJoins());
    }

    public ExtendedIterator<String> listJoins() {
        return listStrings(D2RQ.join);
    }

    public ResourceMap addCondition(String condition) {
        return addLiteral(D2RQ.condition, condition);
    }

    public ExtendedIterator<String> listConditions() {
        return listStrings(D2RQ.condition);
    }

    public Stream<String> conditions() {
        return Iter.asStream(listConditions());
    }

    public ResourceMap addAlias(String alias) {
        return addLiteral(D2RQ.alias, alias);
    }

    public ExtendedIterator<String> listAliases() {
        return listStrings(D2RQ.alias);
    }

    public Stream<String> aliases() {
        return Iter.asStream(listAliases());
    }

    public String getColumn() {
        return getString(D2RQ.column);
    }

    public String getPattern() {
        return getString(D2RQ.pattern);
    }

    public String getSQLExpression() {
        return getString(D2RQ.sqlExpression);
    }

    public String getDatatype() {
        return findURI(D2RQ.datatype).orElse(null);
    }

    public String getLang() {
        return getString(D2RQ.lang);
    }

    public boolean containsDuplicates() {
        return getBoolean(D2RQ.containsDuplicates, false);
    }

    protected Set<Alias> getAliases() {
        return listAliases().mapWith(SQL::parseAlias).toSet();
    }

    public ClassMapImpl getRefersToClassMap() {
        return getClassMap(D2RQ.refersToClassMap);
    }

    public ResourceMap setRefersToClassMap(ClassMap classMap) {
        return setClassMap(D2RQ.refersToClassMap, classMap);
    }

    public ClassMapImpl getBelongsToClassMap() {
        return getClassMap(D2RQ.belongsToClassMap);
    }

    public ResourceMap setBelongsToClassMap(ClassMap classMap) {
        return setClassMap(D2RQ.belongsToClassMap, classMap);
    }

    protected ClassMapImpl getClassMap(Property predicate) {
        return findFirst(predicate, Statement::getResource).map(mapping::asClassMap).orElse(null);
    }

    protected ResourceMap setClassMap(Property predicate, ClassMap classMap) {
        ClassMapImpl res = mapping.asClassMap(classMap.asResource()).copy(classMap);
        return setRDFNode(predicate, res.asResource());
    }

    public RelationBuilder relationBuilder(ConnectedDB cd) {
        return relationBuilder(cd, containsDuplicates());
    }

    public RelationBuilder relationBuilder(ConnectedDB cd, boolean containsDuplicates) {
        RelationBuilder res = new RelationBuilder(cd);
        for (Join join : SQL.parseJoins(listJoins().toList())) {
            res.addJoinCondition(join);
        }
        listConditions().forEachRemaining(res::addCondition);
        res.addAliases(getAliases());
        for (ProjectionSpec projection : nodeMaker().projectionSpecs()) {
            res.addProjection(projection);
        }
        if (!containsDuplicates) {
            res.setIsUnique(true);
        }
        return res;
    }

    public Relation getRelation() {
        return buildRelation();
    }

    protected abstract Relation buildRelation();

    public NodeMaker nodeMaker() {
        boolean isUnique = !containsDuplicates();
        RDFNode constantValue = getConstantValue();
        if (constantValue != null) {
            return new FixedNodeMaker(constantValue.asNode(), isUnique);
        }
        ClassMapImpl refersToClassMap = getRefersToClassMap();
        if (refersToClassMap == null) {
            return buildNodeMaker(wrapValueSource(buildValueSourceBase()), isUnique);
        }
        return refersToClassMap.buildAliasedNodeMaker(new AliasMap(getAliases()), isUnique);
    }

    public NodeMaker buildAliasedNodeMaker(AliasMap aliases, boolean unique) {
        ValueMaker values = wrapValueSource(buildValueSourceBase()).renameAttributes(aliases);
        return buildNodeMaker(values, unique);
    }

    protected ValueMaker buildValueSourceBase() {
        String bNodeIdColumns = getBNodeIdColumns();
        if (bNodeIdColumns != null) {
            return new BlankNodeID(PrettyPrinter.toString(this.asResource()), parseColumnList(bNodeIdColumns));
        }
        String uriColumn = getURIColumn();
        if (uriColumn != null) {
            return new Column(SQL.parseAttribute(uriColumn));
        }
        String uriPattern = getURIPattern();
        if (uriPattern != null) {
            return new PropertyMap(uriPattern).buildValueSourceBase();
        }
        String column = getColumn();
        if (column != null) {
            return new Column(SQL.parseAttribute(column));
        }
        String pattern = getPattern();
        if (pattern != null) {
            return new Pattern(pattern);
        }
        String sqlExpression = getSQLExpression();
        if (sqlExpression != null) {
            return new SQLExpressionValueMaker(SQLExpression.create(sqlExpression));
        }
        String uriSqlExpression = getUriSQLExpression();
        if (uriSqlExpression != null) {
            return new SQLExpressionValueMaker(SQLExpression.create(uriSqlExpression));
        }
        throw new D2RQException(this + " needs a column/pattern/bNodeID specification");
    }

    public ValueMaker wrapValueSource(ValueMaker values) {
        List<ValueConstraint> constraints = new ArrayList<>();
        Integer valueMaxLength = getValueMaxLength();
        if (valueMaxLength != null) {
            constraints.add(ValueDecorator.maxLengthConstraint(valueMaxLength));
        }
        listValueContains().mapWith(ValueDecorator::containsConstraint).forEachRemaining(constraints::add);
        listValueRegexes().mapWith(ValueDecorator::regexConstraint).forEachRemaining(constraints::add);
        TranslationTable translateWith = getTranslateWith();
        if (translateWith == null) {
            if (constraints.isEmpty()) {
                return values;
            }
            return new ValueDecorator(values, constraints);
        }
        return new ValueDecorator(values, constraints, translateWith.asTranslator());
    }

    protected NodeMaker buildNodeMaker(ValueMaker values, boolean isUnique) {
        return new TypedNodeMaker(nodeType(), values, isUnique);
    }

    protected NodeType nodeType() {
        if (getBNodeIdColumns() != null) {
            return TypedNodeMaker.BLANK;
        }
        if (getURIColumn() != null || getURIPattern() != null) {
            return TypedNodeMaker.URI;
        }
        if (getUriSQLExpression() != null) {
            return TypedNodeMaker.URI;
        }
        // literals
        if (getColumn() == null && getPattern() == null && getSQLExpression() == null) {
            throw new D2RQException(this + " needs a column/pattern/bNodeID/sqlExpression/uriSqlExpression specification");
        }
        String datatype = getDatatype();
        String lang = getLang();
        if (datatype != null && lang != null) {
            throw new D2RQException(this + " has both d2rq:lang and d2rq:datatype");
        }
        if (datatype != null) {
            return TypedNodeMaker.typedLiteral(buildDatatype(datatype));
        }
        if (lang != null) {
            return TypedNodeMaker.languageLiteral(lang);
        }
        return TypedNodeMaker.PLAIN_LITERAL;
    }

    private RDFDatatype buildDatatype(String datatypeURI) {
        return TypeMapper.getInstance().getSafeTypeByName(datatypeURI);
    }

    private static List<Attribute> parseColumnList(String commaSeparated) {
        List<Attribute> result = new ArrayList<>();
        for (String attr : commaSeparated.split(",")) {
            result.add(SQL.parseAttribute(attr));
        }
        return result;
    }

    /**
     * To validate all those things which are described in the {@code de.fuberlin.wiwiss.d2rq.map.HasURI} interface.
     */
    protected void commonValidateURI() {
        Validator v = new Validator(this);
        Validator.ForProperty uriPattertn = v.forProperty(D2RQ.uriPattern);
        if (uriPattertn.exists()) {
            uriPattertn.requireHasNoDuplicates(D2RQException.RESOURCEMAP_DUPLICATE_URIPATTERN)
                    .requireIsStringLiteral(D2RQException.RESOURCEMAP_ILLEGAL_URIPATTERN);
        }
        Validator.ForProperty uriColumn = v.forProperty(D2RQ.uriColumn);
        if (uriColumn.exists()) {
            uriColumn.requireHasNoDuplicates(D2RQException.RESOURCEMAP_DUPLICATE_URICOLUMN)
                    .requireIsStringLiteral(D2RQException.UNSPECIFIED);
        }
        Validator.ForProperty constantValue = v.forProperty(D2RQ.constantValue);
        if (constantValue.exists())
            constantValue.requireHasNoDuplicates(D2RQException.RESOURCEMAP_DUPLICATE_CONSTANTVALUE);

        Validator.ForProperty uriSQLExpression = v.forProperty(D2RQ.uriSqlExpression);
        if (uriSQLExpression.exists()) {
            uriSQLExpression.requireHasNoDuplicates(D2RQException.PROPERTYBRIDGE_DUPLICATE_URI_SQL_EXPRESSION)
                    .requireIsStringLiteral(D2RQException.UNSPECIFIED);
        }
    }

    /**
     * To validate all those things which are described in the {@code de.fuberlin.wiwiss.d2rq.map.HasSQL} interface.
     */
    protected void commonValidateSQLAdditions() {
        Validator v = new Validator(this);
        Stream.of(D2RQ.alias, D2RQ.join, D2RQ.condition)
                .map(v::forProperty)
                .forEach(p -> p.requireContainsOnlyStrings(D2RQException.UNSPECIFIED));
    }

    /**
     * To validate all those things which are described in the {@code de.fuberlin.wiwiss.d2rq.map.HasUnclassified} interface.
     */
    protected void commonValidateUnclassifiedAdditions() {
        Validator v = new Validator(this);
        Validator.ForProperty bNodeIdColumns = v.forProperty(D2RQ.bNodeIdColumns);
        if (bNodeIdColumns.exists()) {
            bNodeIdColumns
                    .requireHasNoDuplicates(D2RQException.RESOURCEMAP_DUPLICATE_BNODEIDCOLUMNS)
                    .requireIsStringLiteral(D2RQException.UNSPECIFIED);
        }
        v.forProperty(D2RQ.valueRegex).requireContainsOnlyStrings(D2RQException.UNSPECIFIED);
        v.forProperty(D2RQ.valueContains).requireContainsOnlyStrings(D2RQException.UNSPECIFIED);

        Validator.ForProperty valueMaxLength = v.forProperty(D2RQ.valueMaxLength);
        if (valueMaxLength.exists()) {
            valueMaxLength
                    .requireHasNoDuplicates(D2RQException.PROPERTYBRIDGE_DUPLICATE_VALUEMAXLENGTH)
                    .requireIsPositiveIntegerLiteral(D2RQException.UNSPECIFIED);
        }

        Validator.ForProperty translateWith = v.forProperty(D2RQ.translateWith);
        if (translateWith.exists()) {
            translateWith
                    .requireHasNoDuplicates(D2RQException.RESOURCEMAP_DUPLICATE_TRANSLATEWITH);
            try {
                getTranslateWith().validate();
            } catch (D2RQException e) {
                throw new D2RQException(e.getMessage(), D2RQException.RESOURCEMAP_INVALID_TRANSLATEWITH);
            }
        }
    }
}