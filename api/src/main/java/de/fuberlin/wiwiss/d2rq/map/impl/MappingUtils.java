package de.fuberlin.wiwiss.d2rq.map.impl;

import com.github.owlcs.ontapi.jena.utils.Iter;
import com.github.owlcs.ontapi.jena.vocabulary.RDF;
import de.fuberlin.wiwiss.d2rq.vocab.D2RQ;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Optional;

/**
 * Auxiliary class-helper to retrieve different {@link ResourceMap} for various conditions from a {@link MappingImpl}.
 * <p>
 * Created by @ssz on 06.01.2019.
 */
class MappingUtils {
    private static final Logger LOGGER = LoggerFactory.getLogger(MappingUtils.class);

    /**
     * Finds or creates a {@code PropertyBridge}-impl for the given {@code ClassMap}-impl and {@code rdf:type}.
     *
     * @param c         {@link ClassMapImpl}, not {@code null}
     * @param classType {@link Resource}, type, not {@code null}
     * @return {@link PropertyBridgeImpl}, fresh or found
     */
    static PropertyBridgeImpl fetchPropertyBridge(ClassMapImpl c, Resource classType) {
        MappingImpl m = c.getMapping();
        Optional<PropertyBridgeImpl> res = Iter.findFirst(m.asModel()
                .listResourcesWithProperty(D2RQ.belongsToClassMap, c.asResource())
                .filterKeep(x -> x.hasProperty(D2RQ.property, RDF.type)
                        && x.hasProperty(D2RQ.constantValue, classType))
                .mapWith(m::asPropertyBridge));

        if (res.isPresent()) return res.get();
        PropertyBridgeImpl p = m.createPropertyBridge(null);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Generate {} for {} with d2rq:constantValue {}", p, c, classType);
        }
        return p.setBelongsToClassMap(c)
                .setAutoGenerated()
                .addProperty(RDF.type)
                .setConstantValue(classType);
    }

    /**
     * Finds or creates a {@code ClassMap}-impl for the given {@code PropertyBridge}-impl,
     * {@code rdf:type} and {@code predicate}.
     *
     * @param p         {@link PropertyBridgeImpl}, not {@code null}
     * @param classType {@link Resource}, type, not {@code null}
     * @param predicate {@link Property} predicate that belongs to the {@code p}
     * @return {@link ClassMapImpl}, fresh or found
     * @throws IllegalArgumentException no predicate found
     * @throws IllegalStateException    no database found
     */
    static ClassMapImpl fetchClassMap(PropertyBridgeImpl p, Resource classType, Property predicate) {
        String value = getStringValue(p, predicate);
        DatabaseImpl d = getDatabase(p);
        MappingImpl m = p.getMapping();
        Optional<ClassMapImpl> res = Iter.findFirst(m.asModel()
                .listResourcesWithProperty(D2RQ.clazz, classType)
                .filterKeep(r -> r.hasProperty(predicate, value) && r.hasProperty(D2RQ.dataStorage, d.resource))
                .mapWith(m::asClassMap));
        if (res.isPresent()) return res.get();
        ClassMapImpl c = m.createClassMap(null);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Generate {} for {} with type {} and value {}='{}'", c, p, classType, predicate, value);
        }
        return c.setDatabase(d)
                .setAutoGenerated()
                .addClass(classType)
                .setLiteral(predicate, value);
    }

    /**
     * Finds or creates a {@code ClassMap}-impl for the given {@code PropertyBridge}-impl
     * and {@link D2RQ#uriPattern d2r:uriPattern}.
     *
     * @param p          {@link PropertyBridgeImpl}, not {@code null}
     * @param uriPattern String, not {@code null}
     * @return {@link ClassMapImpl}
     * @throws IllegalStateException no database found
     */
    static ClassMapImpl fetchClassMap(PropertyBridgeImpl p, String uriPattern) {
        DatabaseImpl d = getDatabase(p);
        MappingImpl m = p.getMapping();
        Optional<ClassMapImpl> res = Iter.findFirst(m.classMapResources()
                .filterKeep(r -> r.hasProperty(D2RQ.uriPattern, uriPattern) && r.hasProperty(D2RQ.dataStorage, d.resource))
                .mapWith(m::asClassMap));
        if (res.isPresent()) return res.get();
        ClassMapImpl c = m.createClassMap(null);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Generate {} for {} with uriPattern '{}'", c, p, uriPattern);
        }
        return c.setDatabase(d).setAutoGenerated().setURIPattern(uriPattern);
    }

    private static DatabaseImpl getDatabase(ResourceMap p) throws IllegalStateException {
        DatabaseImpl res = p.getDatabase();
        if (res == null) throw new IllegalStateException("Can't find database for " + p);
        return res;
    }

    private static String getStringValue(ResourceMap p, Property predicate) throws IllegalArgumentException {
        return p.findString(predicate)
                .orElseThrow(() -> new IllegalArgumentException("Can't find " + predicate + " for " + p));
    }
}
